---
title: 设计模式
date: 2019-08-30 16:19:57
tags:
    - 设计模式
---
# 设计模式

> 每一个模式描述了在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样你就能一次又一次的使用该方案而不用重复劳动。





# 工厂模式
实际上工厂模式常规来说分为简单工厂模式和抽象工厂模式，后者是前者的升级模式，所以这里直接针对后者来说。

提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类名。

 - 因为不需要指定具体的类名，增加了系统拓展性，降低代码之间的耦合。
 - 切割代码，使得具体化类的工作延迟到了子类中。这也是抽象的意义。
 
 当需要不同的产品时，抽象工厂屏蔽了实现的细节，客户端不直接和具体工厂打交道。当产品种类需要修改或者变更时，客户端不会收到影响。或者像更换主题一样，更换另一套产品时只需要更改调用参数，对客户端影响很小。
 
 ## 组成
 1. 抽象工厂，定义了生产的产品线。
 2. 具体工厂，实现了不同产品线的生产方式。
 3. 抽象产品，定义产品主要功能。
 4. 具体产品。
 5. 客户端。
 
 ## 效果
 1. 分离了具体的类，降低耦合
 2. 易于更换产品序列
 3. 有利于产品的一致性，产品永远是同序列的。
 4. 难以支持新的产品线。产品线是在抽象抽象工厂中定义，如果更改会对所有具体工厂产生影响。
 
 ## 代码
```java
/**
 * 抽象工厂类，规定了两条产品线
 */
public interface  Factory {
    public Phone makePhone();
    public Computer makeComputer();
}
```
```java
/**
 * 具体工厂
 */
public class HuaweiFactory implements Factory {
    @Override
    public Phone makePhone() {
        return new HuaweiPhone();
    }

    @Override
    public Computer makeComputer() {
        return new HuaweiComputer();
    }
}
```
```java
/**
 * 具体工厂
 */
public class XiaomiFactory implements Factory {
    @Override
    public Phone makePhone() {
        return new XiaomiPhone();
    }

    @Override
    public Computer makeComputer() {
        return new XiaomiComputer();
    }
}

```
```java
/**
 * 抽象产品
 */
public interface Phone {
    public void call();
}

```
```java
/**
 * 抽象产品
 */
public interface Computer  {
    public void compute();
}

```
```java
/**
 * 具体产品
 */
public class HuaweiComputer implements  Computer {
    @Override
    public void compute() {
        System.out.println("HuaweiComputer computing");
    }
}
```
```java
/**
 * 具体产品
 */
public class HuaweiPhone implements Phone {
    @Override
    public void call() {
        System.out.println("HuaweiPhone calling");
    }
}

```
```java
/**
 * 具体产品
 */
public class XiaomiComputer implements Computer {
    @Override
    public void compute() {
        System.out.println("XiaomiComputer computing");
    }
}
```
```java
/**
 * 具体产品
 */
public class XiaomiPhone implements Phone{
    @Override
    public void call() {
        System.out.println("Mix2S calling");
    }
}
```
```java
/**
 * 客户端
 */
public class FactoryClient {
    private Factory factory;

    public Phone buyPhone(int i){
        switch (i){
            case 1:
                factory = new HuaweiFactory();
                break;
            case 2:
                factory = new XiaomiFactory();
                break;
            default:
        }
        return factory.makePhone();
    }

    public static void main(String[] args) {
        FactoryClient factoryClient = new FactoryClient();
        Phone phone = factoryClient.buyPhone(1);
        phone.call();
        Phone phone2 = factoryClient.buyPhone(2);
        phone2.call();

    }
}
```
# 单例模式

保证一个类的对象只有一个实例，并提供一个全局能访问到实例的方法

## 效果

1. 对唯一实例访问的控制
2. 缩小命名空间，避免全局变量污染空间
3. 在内存里只有一个实例，减少了内存的开销
4. 允许可变数目的实例
5. 难以拓展，一般直接重新写
6. 提供工厂方法，职责过重

## 组成

1. 私有化构造方法
2. 内部维护对象实例
3. 暴露全局方法获取实例对象
```java
/**
 * 饿汉式单例模式
 */
public class Singleton implements Serializable {
    // 内部维护实例引用，必须是static。volatile 保证 创建对象 的原子性。
    private static volatile Singleton instance;
    // 私有化构造方法
    private Singleton(){
        if(instance != null){
            throw new RuntimeException("非法访问构造方法");
        }
    }

    // 双重检查比直接方法加锁效率更高
    public static Singleton getInstance(){
        if(instance == null){
            synchronized (Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }

    // 避免序列化创造出多个实例
    private Object readResolve() throws ObjectStreamException {
        return instance;
    }
}

class LazySingleton{
    private static LazySingleton instance = new LazySingleton();
    private LazySingleton(){}
    public static LazySingleton getInstance(){
        return instance;
    }
}

class StaticSingleton{
    private static class Holder{
        private static final StaticSingleton INSTANCE = new StaticSingleton();
    }

    private StaticSingleton(){}

    public static StaticSingleton getInstance(){
        return Holder.INSTANCE;
    }
}
// 枚举是最安全也是推荐的实现单例方式，避免反射攻击
enum EnumSingleton{

    INSTANCE("张三");

    private String name;

    EnumSingleton(String name){
        this.name = name;
    }
    public String getName(){
        return name;
    }
}

```

## 适用

1. 实例耗费资源，一个实例足够使用。例如数据库驱动，配置文件。

## 思考

### 安全性

1. Java 中通过private来限制对单例类构造方法的调用，但是实际上可以通过反射来访问到构造方法，从而创造出更多实例。此时应该在构造方法中判断实例不为空则抛出异常。

   ```java
       private Singleton(){
           if(instance != null){
               throw new RuntimeException();
           }
       }
   ```

   

2. 单例对象序列化传递后，反序列化仍然可以创建出多个实例。序列化接口没有具体方法，但是规定了几个特定签名方法，可以解决单例反序列化问题

   ```java
       private Object readResolve() throws ObjectStreamException {
           return instance;
       }
   ```

### Spring 中的实现

spring中单例模式并没有按照标准要求将Bean的构造方法私有化。实际上spring是在一个map中存储了所有bean实例，在需要注入时，从map中取出bean实例，否则才会创建bean。虽然和传统单例实现方式完全不一样，但是也达到了同样的目的。