---
title: 设计模式
date: 2019-08-30 16:19:57
tags:
    - 设计模式
---
# 设计模式

> 每一个模式描述了在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样你就能一次又一次的使用该方案而不用重复劳动。





# 工厂模式
实际上工厂模式常规来说分为简单工厂模式和抽象工厂模式，后者是前者的升级模式，所以这里直接针对后者来说。

提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类名。

 - 因为不需要指定具体的类名，增加了系统拓展性，降低代码之间的耦合。
 - 切割代码，使得具体化类的工作延迟到了子类中。这也是抽象的意义。
 
 当需要不同的产品时，抽象工厂屏蔽了实现的细节，客户端不直接和具体工厂打交道。当产品种类需要修改或者变更时，客户端不会收到影响。或者像更换主题一样，更换另一套产品时只需要更改调用参数，对客户端影响很小。
 
 ## 组成
 1. 抽象工厂，定义了生产的产品线。
 2. 具体工厂，实现了不同产品线的生产方式。
 3. 抽象产品，定义产品主要功能。
 4. 具体产品。
 5. 客户端。
 
 ## 效果
 1. 分离了具体的类，降低耦合
 2. 易于更换产品序列
 3. 有利于产品的一致性，产品永远是同序列的。
 4. 难以支持新的产品线。产品线是在抽象抽象工厂中定义，如果更改会对所有具体工厂产生影响。
 
 ## 代码
 
```java
/**
 * 抽象工厂类，规定了两条产品线
 */
public interface  Factory {
    public Phone makePhone();
    public Computer makeComputer();
}
```
```java
/**
 * 具体工厂
 */
public class HuaweiFactory implements Factory {
    @Override
    public Phone makePhone() {
        return new HuaweiPhone();
    }

    @Override
    public Computer makeComputer() {
        return new HuaweiComputer();
    }
}
```
```java
/**
 * 具体工厂
 */
public class XiaomiFactory implements Factory {
    @Override
    public Phone makePhone() {
        return new XiaomiPhone();
    }

    @Override
    public Computer makeComputer() {
        return new XiaomiComputer();
    }
}

```
```java
/**
 * 抽象产品
 */
public interface Phone {
    public void call();
}

```
```java
/**
 * 抽象产品
 */
public interface Computer  {
    public void compute();
}

```
```java
/**
 * 具体产品
 */
public class HuaweiComputer implements  Computer {
    @Override
    public void compute() {
        System.out.println("HuaweiComputer computing");
    }
}
```
```java
/**
 * 具体产品
 */
public class HuaweiPhone implements Phone {
    @Override
    public void call() {
        System.out.println("HuaweiPhone calling");
    }
}

```
```java
/**
 * 具体产品
 */
public class XiaomiComputer implements Computer {
    @Override
    public void compute() {
        System.out.println("XiaomiComputer computing");
    }
}
```
```java
/**
 * 具体产品
 */
public class XiaomiPhone implements Phone{
    @Override
    public void call() {
        System.out.println("Mix2S calling");
    }
}
```
```java
/**
 * 客户端
 */
public class FactoryClient {
    private Factory factory;

    public Phone buyPhone(int i){
        switch (i){
            case 1:
                factory = new HuaweiFactory();
                break;
            case 2:
                factory = new XiaomiFactory();
                break;
            default:
        }
        return factory.makePhone();
    }

    public static void main(String[] args) {
        FactoryClient factoryClient = new FactoryClient();
        Phone phone = factoryClient.buyPhone(1);
        phone.call();
        Phone phone2 = factoryClient.buyPhone(2);
        phone2.call();

    }
}
```
# 单例模式

保证一个类的对象只有一个实例，并提供一个全局能访问到实例的方法

## 效果

1. 对唯一实例访问的控制
2. 缩小命名空间，避免全局变量污染空间
3. 在内存里只有一个实例，减少了内存的开销
4. 允许可变数目的实例
5. 难以拓展，一般直接重新写
6. 提供工厂方法，职责过重

## 组成

1. 私有化构造方法
2. 内部维护对象实例
3. 暴露全局方法获取实例对象

```java
/**
 * 饿汉式单例模式
 */
public class Singleton implements Serializable {
    // 内部维护实例引用，必须是static。volatile 保证 创建对象 的原子性。
    private static volatile Singleton instance;
    // 私有化构造方法
    private Singleton(){
        if(instance != null){
            throw new RuntimeException("非法访问构造方法");
        }
    }

    // 双重检查比直接方法加锁效率更高
    public static Singleton getInstance(){
        if(instance == null){
            synchronized (Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }

    // 避免序列化创造出多个实例
    // 不明白为什么这个方法不是放在Serializable接口里显式规定，可能是为了避免代码入侵。但是目前这样也太不保险了。
    private Object readResolve() throws ObjectStreamException {
        return instance;
    }
}

class LazySingleton{
    private static LazySingleton instance = new LazySingleton();
    private LazySingleton(){}
    public static LazySingleton getInstance(){
        return instance;
    }
}

class StaticSingleton{
    private static class Holder{
        private static final StaticSingleton INSTANCE = new StaticSingleton();
    }

    private StaticSingleton(){}

    public static StaticSingleton getInstance(){
        return Holder.INSTANCE;
    }
}
// 枚举是最安全也是推荐的实现单例方式，避免反射攻击
enum EnumSingleton{

    INSTANCE("张三");

    private String name;

    EnumSingleton(String name){
        this.name = name;
    }
    public String getName(){
        return name;
    }
}

```

## 适用

1. 实例耗费资源，一个实例足够使用。例如数据库驱动，配置文件。

## 思考

### 安全性

1. Java 中通过private来限制对单例类构造方法的调用，但是实际上可以通过反射来访问到构造方法，从而创造出更多实例。此时应该在构造方法中判断实例不为空则抛出异常。

   ```java
       private Singleton(){
           if(instance != null){
               throw new RuntimeException();
           }
       }
   ```

   

2. 单例对象序列化传递后，反序列化仍然可以创建出多个实例。序列化接口没有具体方法，但是规定了几个特定签名方法，可以解决单例反序列化问题

   ```java
       private Object readResolve() throws ObjectStreamException {
           return instance;
       }
   ```

### Spring 中的实现

spring中单例模式并没有按照标准要求将Bean的构造方法私有化。实际上spring是在一个map中存储了所有bean实例，在需要注入时，从map中取出bean实例，否则才会创建bean。虽然和传统单例实现方式完全不一样，但是也达到了同样的目的。

# 适配器模式

将一个接口转换为客户希望的另一个接口形式。

## 效果

1. 可以让任何两个没有关联的类一起运行。
2. 提高了类的复用。
3. 增加了类的透明度。
4. 灵活性好。
5. 过多地使用适配器，会让系统非常零乱，李代桃僵。
6. 由于 Java 至多继承一个类，所以至多只能适配一个适配者类

## 组成

1. 目标接口
2. 被适配的类
3. 适配器

```java
/**
 * 适配器
 * 类适配器通过继承类实现，对象适配器通过委托来实现
 */
public class Adapter implements Cat{

    private Dog dog;

    public Adapter(Dog dog){
        this.dog = dog;
    }

    @Override
    public void catchMouse() {
        dog.bark();
    }

}

```
```java
/**
 * 目标接口
 */
public interface Cat {
    public void catchMouse();
}

```

```java
/**
 * 被适应的类
 */
public class Dog {
    public void bark(){
        System.out.println("Woo");
    }
}
```
除了这（俩）种适配模式，还有一种缺省适配器。
```java
/**
 * 缺省适配器目标类，有很多方法需要实现
 */
public interface Servlet {
    void get();
    default void post(){
        System.out.println("post method");
    }
}
```
```java
/**
* 缺省适配器首先对所有方法进行默认实现，子类只需要实现自己关心的方法
*/
public abstract class DefaultAdapter implements Servlet{
    @Override
    public void get() {

    }

    @Override
    public void post() {

    }
}
```
```java
/**
* 接口使用默认实现后，本类可以直接实现接口，取消掉继承
*/
public class ConcreteServlet extends DefaultAdapter {
    @Override
    public void get() {
        System.out.println("get method");
    }
}
```
```java
public class Client {
    public static void main(String[] args) {
        //对象或者类适配器
        Cat cat = new Adapter(new Dog());
        cat.catchMouse();

        //缺省适配器
        Servlet servlet = new ConcreteServlet();
        servlet.get();
    }
}
```
## 适用

1. 需要使用一个已经存在但是不符合要求的类
2. 创建一个类，保持它以后与其他类的兼容性
3. 对象适配，不必须修改所有子类，直接适配父类即可，使用时传入子类对象

## 思考

实际上这是对组合和继承联合使用，得到一种欺骗的目的，从类的继承关系上来看是A类，实现却是B类。因为有个委托的关系，和代理模式有很大相似。

缺省适配器在被适配的类中有很多方法，但是实现类只关心少数的时候使用。屏蔽了不关心的方法。但是在JDK 8中增加了接口的默认实现，直接吸收了这种特性。子类不必须实现全部接口方法。实际上示例代码中接口使用了default实现，这种情况下，抽象类不需要存在了，子类直接实现接口就好。
# 装饰器模式

动态得给一个对象增加一些额外的功能，比继承更加灵活。

## 效果

1. 比继承更加灵活，不存在final，多继承的限制。
2. 避免了层次高的对象有太多方法。
3. 改变了原有对象，装饰器和被装饰不再是一个对象，不能依赖原有对象。
4. 因为组合方式的不同产生比较多的小对象，容易造成混乱。

## 组成

1. 抽象部件
2. 具体部件
3. 装饰器


```java
public interface Component {
    void action();
}
```
```java
public class ConcreteComponent implements Component {
    @Override
    public void action() {
        System.out.println("Concrete action");
    }
}
```
```java
public class Decorator implements Component{

    private Component component;
    public Decorator(Component component){
        this.component = component;
    }
    @Override
    public void action() {
        enhance();
        component.action();
    }

    private void enhance(){
        System.out.println("enhance something");
    }
}
```
```java
public class Client {
    public static void main(String[] args) {
        Component component = new ConcreteComponent();
        // 运行时指定被装饰的目标对象，可以达到动态组合的目的以加强不同的功能。和代理模式的主要区别
        Decorator decorator = new Decorator(component);
        decorator.action();
    }
}
```

## 适用

1. 在不影响其他对象的情况下，给单个对象添加额外的功能
2. 使用继承的方式不够灵活的时候。
3. 可以撤销的功能。

## 思考

装饰器模式和代理模式区别并不大。代理模式更加突出的是封闭被代理对象，使得被代理对象完全不向外界暴露，代理类和被代理对象在定义类的时候编译器就已经确定。装饰器更多的动态组合，需要手动传入被装饰的对象，需要在施用的时候指定，并且可以改变被装饰的对象实例。二者都是增加了目标类的功能。

装饰模式的本质是动态组合。动态是手段，组合是目的。每个装饰类可以只负责添加一项额外功能，然后通过组合为被装饰类添加复杂功能。由于每个装饰类的职责比较简单单一，增加了这些装饰类的可重用性，同时也更符合单一职责原则。

# 外观(门面)模式

为子系统中一组接口提供一个一致的界面，外观模式定义了一个高层次的接口使得这一子系统更加容易使用。

## 效果

1. 对客户屏蔽了子系统的实现细节，只保留接口。
2. 降低了子系统和客户之间的耦合
3. 保留了客户直接调用子系统内部实现的可能

## 组成

1. facade 收集整理子系统实现细节，对外暴露组合方法
2. 子系统，提供功能的实现细节。

```java
public class ModuleA {
    public void first(){
        System.out.println("先淘米");
    }
    public void second(){
        System.out.println("再开火");
    }
}

public class ModuleB {
    public void first(){
        System.out.println("洗菜");
    }
    public void second(){
        System.out.println("炒菜");
    }
}
```
```java
/**
* 也可以暴露子系统的实现细节
*/
public class Facade {
    private ModuleA a = new ModuleA();
    private ModuleB b = new ModuleB();

    public void cook(){
        a.first();
        a.second();
        b.first();
        b.second();
    }
}
```
```java
public class Client {
    public static void main(String[] args) {
        Facade facade = new Facade();
        facade.cook();
    }
}
```
## 适用

1. 为复杂子系统提供简单接口
2. 降低子系统之间的耦合性，避免直接的系统内部依赖
3. 提高子系统的隔离，移植性

## 思考

就像整理数据线，把不同的数据线困扎一下，对外只暴漏一个线头。没有必要直接顺着线去找每一根线从哪里出来，只要根据最外面线头标志适用就可以。同时也可以顺着线头往下找，自己组合一个新的功能出来。

外观模式可以有点像抽象工厂模式，并且可以混用。由抽象工厂来提供一个独立的对象，该对象封装了子系统对外的组合接口，同时隐藏内部实现细节。

# 代理模式

为目标对象提供一种代理以控制目标对象的访问

## 效果

1. 屏蔽对象细节，不必直接去管理目标对象
2. 代替耗时对象，推迟耗时操作，避免直接阻塞。
3. 增强功能。
4. 系统可能会很复杂，增加复杂度。
5. 大量额外工作可能会降低客户端相应速度

## 组成

1. 接口。定义了被代理类和代理类的共同方法。
2. 被代理对象，接口的真正实现。
3. 代理对象，包含被代理对象的引用并委托其进行真正的操作。

```java
public interface Subject {
    void update();
}
public class RealSubject implements Subject {
    @Override
    public void update() {
        System.out.println("update something");
    }
}
```
```java
public class Proxy implements Subject{
    private Subject subject;

    public Proxy(){
        // 自行控制被代理对象的创建过程，也可以放在真正需要调用被代理对象的时候创建实现延迟加载。
        this.subject = new RealSubject();
    }

    @Override
    public void update() {
        checkPermission();
        subject.update();
    }

    private void checkPermission(){
        System.out.println("Permission grant");
    }
}

```
```java
public class Client {
    public static void main(String[] args) {
        Subject subject = new Proxy();
        subject.update();
    }
}
```

## 适用

1. 远程代理，屏蔽网络细节。
2. 保护代理，可以在运行期进行权限检查，核实后将调用传递给被代理的对象。
3. 智能引用代理，在访问一个对象时，执行一些内务处理（Housekeeping）操作，比如记录日志等
4. 虚拟代理，使用虚拟代理模式的优点是代理对象可以在必要的时候才将被代理的对象加载。延迟加载模式。

## 思考

代理模式非常流行，JDK1.3后将代理模式纳入了JDK，并使用Proxy实现了动态代理。动态代理和静态代理最大的区别在于代码中规定了动态代理类的行为，但是没有定义动态代理类，动态代理类是在运行时动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。

`InvocationHandler`实际上是目标类的一个静态代理类。`invoke`方法最终委托给了被代理对象。而运行时生成的动态代理类又是 `InvocationHandler`的一个静态代理类，动态代理类的方法调用委托给了`invoke`。所以实际上JDK的动态代理就是二层静态代理。